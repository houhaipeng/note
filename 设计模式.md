# 设计模式

>
>
>

## 1. 七大原则

- **单一职责原则**
- 接口隔离原则
- 依赖倒转原则
- **里氏替换原则：**

- **开闭原则：**

	1. 一个软件实体如类，模块和函数应该**对扩展开放，对修改关闭**。用抽象构建框架，用实现扩展细节。

- **迪米特法则：**

	1. 又叫**最少知道原则，**即一个类对自己依赖的类知道的越少越好。也就是说，对于被依赖的类不管多么复杂，都尽量将逻辑封装在类的内部。对外除了提供的public方法，不对外泄漏任何信息。

	2. 迪米特法则还有个更简单的定义：**只与直接的朋友通信**。
	3. 直接的朋友：我们称出现**成员变量**，**方法参数**，**方法返回值**中的类为直接的朋友，而出现在局部变量中的类不是直接的朋友。也就会说，陌生的类最好不要以局部变量的形式出现在类的内部。

- 合成复用原则

## 2. UML及类之间的关系



## 3. 23种设计模式

### 3.1 命令模式

1. 将**发起请求的对象**和**执行请求的对象**解耦。发起请求的对象是调用者，调用者只要调用命令对象的`execute()`方法就可以让接收者工作，而不必知道具体的接收者对象是谁，是如何实现的，命令对象会负责让接收者执行请求命令的动作，也就是说：**请求发起者**和**请求执行者**之间的解耦是通过命令对象实现的，命令对象起到了纽带桥梁的作用。
2. 容易设计一个命令队列，只要把命令对象放到队列，就可以多线程的执行命令
3. 容易实现对请求的撤销和重做
4. 空命令也是一种设计模式，它为我们省去了判空的操作
5. 命令模式经典的应用场景：界面的一个按钮都是一条命令，模拟CMD(DOS命令)，订单的撤销/恢复，触发-反馈机制

### 3.2 观察者模式

**Subject + Observer = 观察者模式**

1. Subject有三个方法

```
registerObserver();注册观察者
removeObserver();移除观察者
notifyObserver();当主题状态改变时，调用该方法，以通知所有的观察者
```

2. Observer有一个方法

```
update();
```

3. 观察者模式：定义了对象之间一对多依赖，被依赖对象为Subject,依赖对象为Observer.

### 3.3 职责链模式

1. 职责链模式（Chain of Responsibility Pattern）,又叫责任链模式，为请求创建了一个接收者的链。这种模式对请求的发送者和接收者进行解耦。
2. 职责链模式通常每个接收者都包含另一个接收者的引用。如果一个对象不能处理该请求，那么他会把相同的请求传给下一个接收者，以此类推。
3. 这种类型的设计模式属于行为型模式

### 3.4 代理模式

#### 3.4.1 静态代理

#### 3.4.2 动态代理

1. 代理对象不需要实现接口

#### 3.4.3 Cglib代理

1. 静态代理和JDK代理都要求目标对象实现一个接口，但是有时候目标对象只是一个单独的对象，并没有实现任何的接口，这时候可使用目标对象子类来实现代理-这就是**Cglib代理**
2. Cglib代理也叫做子类代理，它是在内存中构建的一个子类对象从而实现对目标对象功能扩展，有些书也将Cglib代理归属到动态代理
3.  Cglib是一个强大的高性能的代码生成包，他可以在运行期扩展java类与实现java接口。被广泛应用到许多AOP框架中，如Spring AOP,实现方法拦截。
4. 在AOP编程中如何选择代理模式：
	- 目标对象需要实现接口，用JDK代理
	- 目标对象不需要实现接口，用Cglib代理
5. Cglib包的底层是通过使用字节码处理框架ASM来转换字节码并生成新的类

### 3.5 模板方法模式

1. 在一个抽象类公开定义了执行它的方法的模板，它的子类可以按需要重写方法实现，但调用将以抽象类中定义的方式进行。
2. 一个抽象类中有模板方法（template），它定义了算法的大致流程

```
abstractClass {
	template() {
		method1();
		method2();
		method3();
		
	}
	//可以是抽象方法，也可以是实现方法
	method1();
	method2();
	method3();
	...
}
```

3. **钩子方法**：在模板方法模式的父类中，我们可以定义一个方法，它默认不做任何事，子类可以视情况要不要覆盖他，该方法称为“钩子”

### 3.6 原型模式

1. Java中Object类是所有类的根类，Object类提供了一个clone方法，该方法可以将一个Java对象复制一份，但是需要实现clone的Java类必须要是心啊一个接口Cloneable,该接口表示该类能够复制且具有复制的能力.

**浅拷贝**

1. 对于数据类型是基本数据类型的成员变量，浅拷贝会直接进行值传递，也就是将该属性值复制一份给新的对象。
2. 对于数据类型是引用数据类型的成员变量，比如成员变量是某个数组，某个类的对象等，那么浅拷贝会进行引用传递，也就是只是将该成员变量的引用值（内存地址）复制一份给新的对象。因此实际上两个对象的成员变量都指向同一个实例。在这种情况下，在一个对象中修改该成员变量会影响到另一个对象的该成员变量值。
3. 浅拷贝使用默认clone()来实现

**深拷贝**

1. 为所有引用数据类型的成员变量申请存储空间，并复制每个引用数据类型成员变量所引用的对象。
2. 实现方式
	- 重写clone方法来实现深拷贝
	- 通过对象序列化实现深拷贝(推荐)

### 3.7 策略模式

策略模式定义了算法族，分别封装起来，让它们之间可以互相替换，此模式让算法的变化独立于使用算法的客户

### 3.8 工厂模式

定义一个创建产品对象的工厂接口，将产生对象的实际创建工作推迟到具体子工厂类中

**分类**

1. 简单工厂模式：又称静态工厂方法模式

